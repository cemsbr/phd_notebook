"""Module for bundle management."""
import abc
import logging
from datetime import datetime
import sys
from os import path
from pathlib import Path

from .bundler import Bundler


class BaseBundle(metaclass=abc.ABCMeta):
    """Bundle management."""

    def __init__(self, *basenames):
        """Required information for bundles.

        Args:
            basenames (str): List of filenames that are generated by this
                bundle. Only basenames, do not include folders.
        """
        self.basenames = basenames
        child_file = sys.modules[self.__module__].__file__
        #: str: Dir of the Bundle class (BaseBundle's child).
        self.path = path.dirname(child_file)
        #: list: Path for basenames.
        self.filenames = [path.join(self.path, b) for b in basenames]
        #: str: Bundle's name is the deepest dir's name.
        self.name = path.basename(self.path)
        #: logging.Logger: Logger.
        self.log = self._get_logger()
        #: list: List of bundle dependencies
        self.dependencies = []
        self._start = None

        self.bundler = Bundler
        # If bundles_root is not set (i.e. update() is called inside a Bundle's
        # module), set bundles_root as the parent folder of the child class.
        # It assumes that all bundles are inside one directory only, for
        # example:
        # - bundles' root
        #   - bundle1 folder
        #   - bundle2 folder
        #   - ...
        if Bundler.bundles_root is None:
            Bundler.bundles_root = path.dirname(self.path)

    @property
    def basename(self):
        """Shortcut when there is only one basename."""
        return self.basenames[0] if len(self.basenames) == 1 else None

    @property
    def filename(self):
        """Shortcut when there is only one basename/filename."""
        return self.filenames[0] if len(self.filenames) == 1 else None

    def get_file(self, basename=None):
        """Return the path for filename.

        Args:
            basename (str): File basename. Can be ommited if bundle has only
                one basename.
        """
        self.update()
        if basename is None:
            basename = self.basename
        for filename in self.filenames:
            if filename.endswith(basename):
                return filename
        raise FileNotFoundError(path.join(self.path, basename))

    def update(self):
        """Run the bundle if any filename is missing.

        You probably don't want to override this method, but :method:`run`.
        """
        for filename in self.filenames:
            file = Path(filename)
            if not file.exists():
                self.log.info('File %s not found.', file.name)
                self.check_dependencies()
                self.run()
                break

    def start(self):
        """Save start time and check dependencies."""
        self.log.info('Started...')
        self._start = datetime.now()

    @abc.abstractmethod
    def run(self):
        """:attribute:`filenames` generation."""
        pass

    def finish(self):
        """Log :method:`run` duration. Don't forget to call :method:`start`."""
        duration = datetime.now() - self._start
        self.log.info('Finished. Duration: %s', duration)

    def check_dependencies(self):
        """Run dependencies if necessary."""
        for bundle_name in self.dependencies:
            bundle = Bundler.get_bundle(bundle_name)
            bundle.update()

    def _get_logger(self):
        logger = logging.Logger(self.name + ', BaseBundle')
        ch = logging.StreamHandler()
        ch.setLevel(logging.INFO)
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s '
                                      '- %(message)s')
        ch.setFormatter(formatter)
        logger.addHandler(ch)
        return logger


def update_bundle(name):
    bundle = Bundler.get_bundle(name)
    bundle.update()
